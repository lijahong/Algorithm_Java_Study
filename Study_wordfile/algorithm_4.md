다이나믹 프로그래밍
======================


## 1. 이론
> 
> - 면접 문제로 많이 나옴
> - 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
> - 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산 하지 않도록 함
> - 구현 방식은 탑다운(큰 문제에서 작은 문제 -> 재귀로 작은 문제 호출)과 보텀업(작은 문제에서 큰 문제)으로 구성
> - 동적 계획법으로 자료구조에서 동적할당은 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법을 의미한다. 근데 다이나믹 프로그래밍에서 다이나믹은 별다른 의미 없이 사용된 단어.
> - 점화식 세워서 푸는게 좋음
> - 코드는 항상 아래와 같이 구성
> > 1. 이미 있는거 반환하는 조건
> > 2. 점화식



## 2. 사용조건 -> 두 조건에 해당되야됨
> 
> - 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제 답을 모아서 큰 문제 해결
> - 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결
> >
> > 1. 주어진 문제가 다이나믹 프로그래밍 유형입을 파악해야됨
> > 2. 일단 재귀로 완전 탐색을 짜고, 작은 문제에서 구한 답이 큰 문제에서 사용되면 코드 개선
> > 3. 일반적으로 코테에서는 기본 유형의 다이나믹이 출제됨


## 3. 예시
> 
> #### 1. 피보나치 수열 
> >
> >  + 시간복잡도 : o(2^n) , 세타 -> 일반적으로 너무 많이 호출되서 오래 걸림
> >  + 피보나치 다이나믹 프로그래밍 (두 조건에 해당) 
> >  + 탑다운은 확인할 수 부터 호출해서, 보텀업은 0부터 시작해서 반복문으로 올라감.
> 
> #### 2. 개미 전사 문제 
> >  
> > + 곡식 창고를 터는 문제 였는데 설명 필요
> 
> #### 3. 1로 만들기 
<pre>
  <code>
for (int i = 2; i<= x; i++){

  d[i] = d[i-1] +1;
  
  if(i % 2 == 0)
    d[i] = Math.min(d[i], d[i/2] +1);
    
  if(i % 3 == 0)
    d[i] = Math.min(d[i], d[i/3] +1);
    
  if(i % 5 == 0)
    d[i] = Math.min(d[i], d[i/5] +1);   
  </code>
</pre>
> #### 4. 효율적인 화폐 구성
> > - n원을 위해 가장 최소한의 화폐 개수 구하기
> > - 각 화폐의 단위마다 경우를 확인

## 4. 탑다운 vs 보텀업
>
> - 탑다운 (메모이제이션) 은 상향식, 보텀업은 하향식
> >
> >  + 메모이제이션 : 다이나믹 프로그래밍을 구현하는 방법 중 하나로, 한 번 계산한 문제를 메모리에 넣어 저장

## 5. 다이나믹 vs 분할정복
>
> - 다이나믹과 분할 정복은 모두 최적 부분 구조를 가질때 사용할 수 있다.
> - 차이점은 부분 문제의 중복
> >
> > 1. 다이나믹은 각 부분 문제들이 서로 영향을 미치며 중복
> > 2. 분할 정복은 동일한 부분 문제가 반복적으로 계산되지 않음

## 6. sw 마에스트로
>
> - 자기소개서 막 빡세진 않음
> - 역량보다는 열정을 많이 보여주는게 나음
> - 혹은 네이버 부트캠프도 좋을지도
> - 대학원 진학시 : 학점과 데이콘도 좋음 (딥러닝)
> - 한이음 ict 멘토링도 좋음

## 7. 잡담
> - 말 잘하는거, 추천서 받는거, 이직하는거 중요
> - 투 포인터 코테에 자주 나옴
> - 학교 다니면서 포트폴리오 만들어라
> - 

## 7. Backjoon 문제
> 1003 : 피보나치 
>
> (https://github.com/lijahong/algorithm_java/blob/main/Four_study/1003.java)
>
> 9184 : 함수  
> (https://github.com/lijahong/algorithm_java/blob/main/Four_study/9184.java)
